import { Injectable } from '@nestjs/common';
import { gql } from 'apollo-server-core';
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import { extend } from './utils';
import { isEmpty, forEach } from 'lodash';
import {
  ScalarsExplorerService,
  DelegatesExplorerService,
  ResolversExplorerService,
} from './services';
import { mergeSchemas } from 'graphql-tools';
import { GqlModuleOptions } from './interfaces';
import { GraphQLSchemaBuilder } from './graphql-schema-builder';
import { GraphQLFactory } from './graphql.factory';
import { GraphQLSchema, GraphQLSchemaConfig } from 'graphql';
import { GraphQLObjectType } from 'graphql';

@Injectable()
export class GraphQLFederationFactory {
  constructor(
    private readonly resolversExplorerService: ResolversExplorerService,
    private readonly delegatesExplorerService: DelegatesExplorerService,
    private readonly scalarsExplorerService: ScalarsExplorerService,
    private readonly gqlSchemaBuilder: GraphQLSchemaBuilder,
    private readonly graphqlFactory: GraphQLFactory,
  ) {}

  async mergeOptions(options: GqlModuleOptions = {}): Promise<GqlModuleOptions> {
    const transformSchema = async s => (options.transformSchema ? options.transformSchema(s) : s);

    let schema: GraphQLSchema;
    if (options.autoSchemaFile) {
      // Enable support when Directive support in type-graphql goes stable
      throw new Error('Code-first not supported yet');
      schema = await this.generateSchema(options);
    } else if (!isEmpty(options.typeDefs)) {
      schema = options.schema;
    } else {
      schema = this.buildSchemaFromTypeDefs(options);
    }

    return {
      ...options,
      schema: await transformSchema(schema),
      typeDefs: undefined,
    };
  }

  private buildSchemaFromTypeDefs(options: GqlModuleOptions) {
    const { buildFederatedSchema } = loadPackage('@apollo/federation', 'ApolloFederation');

    return buildFederatedSchema([
      {
        typeDefs: gql`
          ${options.typeDefs}
        `,
        resolvers: this.getResolvers(options.resolvers),
      },
    ]);
  }

  private async generateSchema(options: GqlModuleOptions): Promise<GraphQLSchema> {
    const { buildFederatedSchema, printSchema } = loadPackage(
      '@apollo/federation',
      'ApolloFederation',
    );

    const autoGeneratedSchema: GraphQLSchema = await this.gqlSchemaBuilder.buildFederatedSchema(
      options.autoSchemaFile,
      options.buildSchemaOptions,
      this.resolversExplorerService.getAllCtors(),
    );
    const executableSchema = buildFederatedSchema({
      typeDefs: gql(printSchema(autoGeneratedSchema)),
      resolvers: this.getResolvers(options.resolvers),
    });

    const schema = options.schema
      ? mergeSchemas({
          schemas: [options.schema, executableSchema],
        })
      : executableSchema;

    return schema;
  }

  private getResolvers(optionResolvers) {
    optionResolvers = Array.isArray(optionResolvers) ? optionResolvers : [optionResolvers];
    return this.extendResolvers([
      this.resolversExplorerService.explore(),
      this.delegatesExplorerService.explore(),
      ...this.scalarsExplorerService.explore(),
      ...optionResolvers,
    ]);
  }

  private extendResolvers(resolvers: any[]) {
    return resolvers.reduce((prev, curr) => extend(prev, curr), {});
  }
}
